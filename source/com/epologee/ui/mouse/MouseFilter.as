package com.epologee.ui.mouse {	import flash.display.Stage;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getQualifiedClassName;		/**	 * @author Eric-Paul Lecluse | epologee.com © 2008	 * 	 * On certain platform/browser/plugin combinations, the MouseEvent.MOUSE_MOVE and Event.MOUSE_LEAVE events	 * go crazy. They're triggered when the cursor is no where near the stage, which is completely annoying.	 * 	 * That's where this class comes in. Listen to an instance of MouseFilter instead of the stage, and you'll	 * only get mouse events that matter. Hurray!	 * 	 * As an added bonus, this class will also pass the SWF's Event.DEACTIVATE (fired on loss of focus) as a	 * MOUSE_LEAVE event.   	 */	public class MouseFilter extends EventDispatcher {		private var _stage:Stage;		private var _mouseInStage:Boolean;		private var _deactivationTimer:Timer;		public function MouseFilter(inStage:Stage, inDeactivationTime:int = 3000) {			_stage = inStage;			_deactivationTimer = new Timer(inDeactivationTime, 1);		}		override public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void {			super.addEventListener(type, listener, useCapture, priority, useWeakReference);			// The event listeners depend on eachother, hence no breaks in the switch:			switch (type) {				case MouseFilterEvent.INACTIVITY_TIMEOUT:					_deactivationTimer.addEventListener(TimerEvent.TIMER, dispatchTimeout);					addEventListener(Event.DEACTIVATE, handleDeactivation);				case Event.MOUSE_LEAVE:					_stage.addEventListener(Event.MOUSE_LEAVE, filterMouseLeave);				case MouseEvent.MOUSE_MOVE:					_stage.addEventListener(MouseEvent.MOUSE_MOVE, filterMouseMove);					break;			} 		}				private function dispatchTimeout(event:TimerEvent):void {			dispatchEvent(new MouseFilterEvent(MouseFilterEvent.INACTIVITY_TIMEOUT));		}		private function filterMouseMove(event:MouseEvent):void {			if (testMouseHit(_stage)) {				if (!_mouseInStage) {					dispatchEvent(new MouseFilterEvent(MouseFilterEvent.REACTIVATED));				}				_mouseInStage = true;				dispatchEvent(event);								_deactivationTimer.stop();			} else {				filterMouseLeave(new Event(Event.MOUSE_LEAVE));			}		}		private function handleDeactivation(event:Event):void {			filterMouseLeave(new Event(Event.MOUSE_LEAVE));		}		private function filterMouseLeave(event:Event):void {			if (_mouseInStage) {				_mouseInStage = false;				dispatchEvent(event);				_deactivationTimer.reset();				_deactivationTimer.start();			}		}				public static function testMouseHit(inStage:Stage):Boolean {			if (0 <= inStage.mouseX && inStage.mouseY <= inStage.stageHeight) {				if (0 <= inStage.mouseY && inStage.mouseY <= inStage.stageHeight) {					return true;				}			}			return false;		}		override public function toString():String {			// com.epologee.util.MouseFilter			return getQualifiedClassName(this);		}	}}