package com.epologee.animation.framebuffer {	import com.epologee.development.logging.logger;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.geom.Point;	import flash.utils.getQualifiedClassName;	import flash.utils.getTimer;	/**	 * @author Eric-Paul Lecluse | epocom (c) 2008	 * 	 * De supertruc van Matthijs Kamstra: Alle frames bufferen	 */	public class FrameBuffer extends EventDispatcher {		public static const DEFAULT_CHUNK_TIME:uint = 150;		private var _height:int;		private var _width:int;		private var _frames:Array;		private var _destination:Point;		private var _bufferIndex:Number;		private var _timeline:MovieClip;		private var _chunkTime:uint;		private var _realtime:Boolean;		public function FrameBuffer(inTimeline:MovieClip, inWidth:int, inHeight:int, inRealtimeBuffering:Boolean = false, inChunkTime:uint = DEFAULT_CHUNK_TIME) {			_frames = [];			_width = inWidth;			_height = inHeight;			_realtime = inRealtimeBuffering;			_chunkTime = inChunkTime;						_destination = new Point();			_timeline = inTimeline;			_timeline.stop();			_timeline.addEventListener(Event.ENTER_FRAME, _realtime ? bufferFramesRealtime : bufferFramesByChunk);					if (_realtime) _timeline.gotoAndPlay(1);			logger.info("FrameBuffer: STARTED " + (_realtime ? "REALTIME" : "BY CHUNKS"));		}		/**		 * Simultate gotoAndStop() for the timeline array.		 */		public function copyFrameTo(inDestination:BitmapData, inFrame:int):void {			var frame:BitmapData = _frames[inFrame] as BitmapData;						if (!frame) {				logger.error("copyFrame: no frame found at " + inFrame);				return;			}						inDestination.copyPixels(frame, frame.rect, _destination);		}		/**		 * Call this method if you want to free the memory of the buffered frames.		 */		public function releaseMemory():void {			while (_frames.length) {				var bmp:BitmapData = _frames.pop() as BitmapData;				if (bmp) bmp.dispose();			}		}		private function bufferFramesRealtime(e:Event = null):void {			_bufferIndex = _timeline.currentFrame;			if (!_frames[_bufferIndex])	_frames[_bufferIndex] = bufferFrame();						if (_bufferIndex < _timeline.totalFrames) return;			// release inTimeline.			_timeline.removeEventListener(Event.ENTER_FRAME, bufferFramesRealtime);			_timeline = null;			logger.info("bufferFramesRealtime: FINISHED");			dispatchEvent(new FrameBufferEvent(FrameBufferEvent.BUFFERED));		}		private function bufferFramesByChunk(e:Event = null):void {			// initialize bufferindex			if (!_bufferIndex) _bufferIndex = 0;										// start timer for monitoring processing timeouts:			var startTime:int = getTimer();						// loop through chunks			while (++_bufferIndex <= _timeline.totalFrames) {				_timeline.gotoAndStop(_bufferIndex);								_frames[_bufferIndex] = bufferFrame();								if (getTimer() - startTime > _chunkTime) return;			}						// release inTimeline.			_timeline.removeEventListener(Event.ENTER_FRAME, bufferFramesByChunk);			_timeline = null;			logger.info("bufferFramesByChunk: FINISHED");			dispatchEvent(new FrameBufferEvent(FrameBufferEvent.BUFFERED));		}		private function bufferFrame():BitmapData {			var frame:BitmapData = new BitmapData(_width, _height, true, 0);			frame.draw(_timeline);			return frame;		}		override public function toString():String {			// nl.noise.hero.world.rotation.TimelineArray			return getQualifiedClassName(this);		}	}}